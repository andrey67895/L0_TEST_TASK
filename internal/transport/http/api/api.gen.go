// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Delivery defines model for Delivery.
type Delivery struct {
	Address string `json:"address"`
	City    string `json:"city"`
	Email   string `json:"email"`
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Region  string `json:"region"`
	Zip     string `json:"zip"`
}

// Item defines model for Item.
type Item struct {
	Brand       *string `json:"brand,omitempty"`
	ChrtId      int     `json:"chrt_id"`
	Name        string  `json:"name"`
	NmId        *int    `json:"nm_id,omitempty"`
	Price       int     `json:"price"`
	Rid         string  `json:"rid"`
	Sale        *int    `json:"sale,omitempty"`
	Size        *string `json:"size,omitempty"`
	Status      *int    `json:"status,omitempty"`
	TotalPrice  *int    `json:"total_price,omitempty"`
	TrackNumber string  `json:"track_number"`
}

// Order defines model for Order.
type Order struct {
	CustomerId        *string    `json:"customer_id,omitempty"`
	DateCreated       *time.Time `json:"date_created,omitempty"`
	Delivery          Delivery   `json:"delivery"`
	DeliveryService   *string    `json:"delivery_service,omitempty"`
	Entry             string     `json:"entry"`
	InternalSignature *string    `json:"internal_signature,omitempty"`
	Items             []Item     `json:"items"`
	Locale            *string    `json:"locale,omitempty"`
	OofShard          *string    `json:"oof_shard,omitempty"`
	OrderUid          string     `json:"order_uid"`
	Payment           Payment    `json:"payment"`
	Shardkey          *string    `json:"shardkey,omitempty"`
	SmId              *int       `json:"sm_id,omitempty"`
	TrackNumber       string     `json:"track_number"`
}

// Payment defines model for Payment.
type Payment struct {
	Amount       int     `json:"amount"`
	Bank         *string `json:"bank,omitempty"`
	Currency     string  `json:"currency"`
	CustomFee    *int    `json:"custom_fee,omitempty"`
	DeliveryCost *int    `json:"delivery_cost,omitempty"`
	GoodsTotal   *int    `json:"goods_total,omitempty"`
	PaymentDt    *int    `json:"payment_dt,omitempty"`
	Provider     string  `json:"provider"`
	RequestId    *string `json:"request_id,omitempty"`
	Transaction  string  `json:"transaction"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /)
	GetApiMainIndexHtml(ctx echo.Context) error

	// (GET /order/{order_uid})
	ApiV1GetOrderByOrderUid(ctx echo.Context, orderUid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiMainIndexHtml converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiMainIndexHtml(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiMainIndexHtml(ctx)
	return err
}

// ApiV1GetOrderByOrderUid converts echo context to params.
func (w *ServerInterfaceWrapper) ApiV1GetOrderByOrderUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "order_uid" -------------
	var orderUid string

	err = runtime.BindStyledParameterWithOptions("simple", "order_uid", ctx.Param("order_uid"), &orderUid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_uid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiV1GetOrderByOrderUid(ctx, orderUid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetApiMainIndexHtml)
	router.GET(baseURL+"/order/:order_uid", wrapper.ApiV1GetOrderByOrderUid)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/5RWwY7bNhD9lQXbo7vypocWujlokRpJkQXWbQ/BQhhTY4tZiWSHI6OOISDpj/TUe1Gg",
	"13yD/UcFKcuWbcqLXLyERsN58+a90W6ENJU1GjU7kW6EkwVWEI4/YKlWSGt/tmQsEisMEchzQheOvLYo",
	"UuGYlF6KZiSk4nU0gBWoMhrRUGE0YAuj4xHCpTI6GvqgbOR5yPm9VoS5SN+1JbsCbc4e+ujQ3aFKh/1x",
	"1N1q5u9Rsq82ZawuCZoT6DxOT0GcqX5MacYl0lUidDWYY0lJjIdIxTE4KAcynPoQB+AYuHbxJDYMZXYF",
	"BxPIp0zX1Rzp+dF0DJ3ldZ22be25ik3kLeVtmdORyNqxqZCyAVJyYMwkITCGFxaGKmCRhsA3rIJeLrN6",
	"HvmacCFS8VVydFSyt1Ny8FIvJ3NIq1PSem7RTHEfeWJJQ5k5tdTANcUvUIxVaPxwuIYvyLg5NAhEELCW",
	"Rp6K5VjAmEXmCqA4ncZPIasHyLawrlDzc6ju9695AfpKTxinxA3b48u0d0R9ob52IL2JH7voyI6p8f7Y",
	"6dkOrUzdPr8EPQf9FN8eNRFquR4IeoVnCxyw4UF30riBwktjcpcFQw9sm7adLOehbWRWKo9S3TKNjocc",
	"yATageT4Yj+bVP/lHi89BKOO4suxNMFGC+PL5OgkKdtWFW/G2ezHh1k2mzy89hpQ7NUvfnt5M0NZPMjC",
	"mPLmzViMxArJtTkguYYyiN6iBqtEKr69Hd+Og0S4CONO/M8SA21eBuALTnORilfIE6t+BqWnOsc/fuKq",
	"DJ8eZ412rVZejMeXUN++9o00I5EE1Sabg3ibwVoTq369e4UcduTLdfjzS1C7BYIKGcmJ9N1GKF/Bg+82",
	"bXrijeMkmGoc7f9riE3tMd6KNJr3tgBrSyUDxuS9a2d/vO/aemg3feAgSo3fDEirrqeaSpGKgtmmSbIp",
	"jOMm3VhD3PhxAimYly3IYm+QHBdQl/4jcPfiOz/R2ztxXmv79/bz7tPuz5vJ/fRm92n73+7j9t/w+08w",
	"hKGzq74fX97x1/bz7uPAHU3z2PwfAAD///mqL3amCQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
